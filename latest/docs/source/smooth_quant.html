

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Smooth Quant &mdash; Intel® Neural Compressor 3.8 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=68dfede1" />

  
<script type="text/javascript">
  // Configure TMS settings
  window.wapProfile = 'profile-microsite'; // This is mapped by WAP authorize value
  window.wapLocalCode = 'us-en'; // Dynamically set per localized site, see mapping table for values
  window.wapSection = "neural-compressor"; // WAP team will give you a unique section for your site
  window.wapEnv = 'prod'; // environment to be use in Adobe Tags.
  // Load TMS
  (() => {
        let url = 'https://www.intel.com/content/dam/www/global/wap/main/wap-microsite.js';
        let po = document.createElement('script'); po.type = 'text/javascript'; po.async = true; po.src = url;
        let s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  }) ();
</script>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Intel® Neural Compressor
          </a>
            <div class="version">
              <a href="../../../versions.html">latest▼</a>
              <p>Click link above to switch version</p>
            </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="get_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation_guide.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_readme.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-doc/apis.html">APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="legal_information.html">Legal Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="SECURITY.html">Security Policy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/intel/neural-compressor">Repo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Intel® Neural Compressor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Smooth Quant</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/docs/source/smooth_quant.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="smooth-quant">
<h1>Smooth Quant<a class="headerlink" href="#smooth-quant" title="Link to this heading"></a></h1>
<ol class="simple">
<li><p><a class="reference external" href="#Introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#Quantization-Fundamentals">Quantization Fundamentals</a></p></li>
<li><p><a class="reference external" href="#SmoothQuant-and-Our-Enhancement">SmoothQuant and Our Enhancement</a></p></li>
<li><p><a class="reference external" href="#Validated-Models">Validated Models</a></p></li>
<li><p><a class="reference external" href="#Usage">Usage</a></p></li>
<li><p><a class="reference external" href="#Supported-Framework-Matrix">Supported Framework Matrix</a></p></li>
</ol>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Quantization is a common compression operation to reduce memory and accelerate inference by converting the floating point matrix to an integer matrix. For large language models (LLMs) with gigantic parameters, the systematic outliers make quantification of activations difficult.  <a class="reference external" href="https://arxiv.org/abs/2211.10438">SmoothQuant</a>, a training free post-training quantization (PTQ) solution, offline migrates this difficulty from activations to weights with a mathematically equivalent transformation.</p>
</section>
<section id="quantization-fundamentals">
<h2>Quantization Fundamentals<a class="headerlink" href="#quantization-fundamentals" title="Link to this heading"></a></h2>
<p>Quantization is a common compression operation to reduce memory and accelerate inference; therefore, the difficulty of LLM deployment can be alleviated. Quantization converts the floating point matrix to an integer matrix.</p>
<p>The equation of quantization is as follows:</p>
<p>$$
X_{int8} = round(X_{fp32}/S) + Z \tag{1}
$$</p>
<p>where $X_{fp32}$ is the input matrix, $S$ is the scale factor,  $Z$ is the integer zero point.</p>
<section id="per-tensor-per-channel">
<h3>Per-tensor &amp; Per-channel<a class="headerlink" href="#per-tensor-per-channel" title="Link to this heading"></a></h3>
<p>There are several choices of sharing quantization parameters among tensor elements, also called quantization granularity. The coarsest level, per-tensor granularity, is that all elements in the tensor share the same quantization parameters. Finer granularity means sharing quantization parameters per row or per column for 2D matrices and per channel for 3D matrices. Similarly, the finest granularity is that each element has an individual set of quantization parameters.</p>
<p>However, due to the model accuracy and computational consumption, per-tensor or per-channel are usually adopted. <strong>In the following part, We will show that per-channel could bring lower quantization loss but has some limitations, that is why normally we use per-channel for weight quantization and per-tensor for activation/input quantization</strong></p>
<section id="per-tensor-example">
<h4>Per-tensor example<a class="headerlink" href="#per-tensor-example" title="Link to this heading"></a></h4>
<p>Suppose the weight tensor is：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="n">W</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">[</span><span class="mf">0.6839</span><span class="p">,</span> <span class="mf">0.4741</span><span class="p">,</span> <span class="mf">0.7451</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.9301</span><span class="p">,</span> <span class="mf">0.1742</span><span class="p">,</span> <span class="mf">0.6835</span><span class="p">],</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>According to the formula (1), we need scale $S$ and zero point $Z$ to calculate the integer matrix.</p>
<p>$$
S = \frac{X_{max} - X{min}}{2^b -1} \tag{2}
$$</p>
<p>$$
Z = -round(X_{min/}/S) \tag{3}
$$</p>
<p>The per-tensor quantization function is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">quantize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_bits</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">**</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
    <span class="n">zp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
    <span class="n">q_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">zp</span>
    <span class="n">q_x</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span><span class="p">)</span><span class="o">.</span><span class="n">round_</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;scale = </span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">, zp = </span><span class="si">{</span><span class="n">zp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q_x</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">zp</span>
</pre></div>
</div>
<p>Then we can get the quantized $W_{q}$</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt;<span class="w"> </span>W_q,<span class="w"> </span>scale,<span class="w"> </span><span class="nv">zp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>quantize<span class="o">(</span>W<span class="o">)</span>
<span class="nv">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.00296431384049356,<span class="w"> </span><span class="nv">zp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-59.0
&gt;&gt;&gt;<span class="w"> </span>W_q
tensor<span class="o">([[</span><span class="m">172</span>.,<span class="w"> </span><span class="m">101</span>.,<span class="w"> </span><span class="m">192</span>.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">255</span>.,<span class="w">   </span><span class="m">0</span>.,<span class="w"> </span><span class="m">172</span>.<span class="o">]])</span>
</pre></div>
</div>
<p>With the value of scale and zp, we can dequantize the tensor.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">dequantize</span><span class="p">(</span><span class="n">q_x</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">zp</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_x</span> <span class="o">-</span> <span class="n">zp</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt;<span class="w"> </span><span class="nv">W_dq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>dequantize<span class="o">(</span>W_q,<span class="w"> </span><span class="m">0</span>.001,<span class="w"> </span>-50<span class="o">)</span>
&gt;&gt;&gt;<span class="w"> </span>W_dq
tensor<span class="o">([[</span><span class="m">0</span>.2220,<span class="w"> </span><span class="m">0</span>.1510,<span class="w"> </span><span class="m">0</span>.2420<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.2570,<span class="w"> </span><span class="m">0</span>.0500,<span class="w"> </span><span class="m">0</span>.1890<span class="o">]])</span>
&gt;&gt;&gt;<span class="w"> </span><span class="nv">loss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.nn.MSELoss<span class="o">()(</span>W_dq,<span class="w"> </span>W<span class="o">)</span>
&gt;&gt;&gt;<span class="w"> </span>loss.item<span class="o">()</span>
<span class="m">0</span>.1983354538679123

&gt;&gt;&gt;<span class="w"> </span><span class="nv">W_dq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>dequantize<span class="o">(</span>W_q,<span class="w"> </span>scale,<span class="w"> </span>zp<span class="o">)</span>
&gt;&gt;&gt;<span class="w"> </span>W_dq
tensor<span class="o">([[</span><span class="m">0</span>.6848,<span class="w"> </span><span class="m">0</span>.4743,<span class="w"> </span><span class="m">0</span>.7440<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.9308,<span class="w"> </span><span class="m">0</span>.1749,<span class="w"> </span><span class="m">0</span>.6848<span class="o">]])</span>
&gt;&gt;&gt;<span class="w"> </span><span class="nv">loss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.nn.MSELoss<span class="o">()(</span>W_dq,<span class="w"> </span>W<span class="o">)</span>
&gt;&gt;&gt;<span class="w"> </span>loss.item<span class="o">()</span>
<span class="m">7</span>.385297635664756e-07
</pre></div>
</div>
<p>The difference between $W$ and $W_{dq}$ shows that quantization affects precision and appropriate values of scale and zero point will reduce the loss of precision.</p>
</section>
<section id="per-channel-example">
<h4>Per-channel example<a class="headerlink" href="#per-channel-example" title="Link to this heading"></a></h4>
<p>Similarly, the example of per-channel quantization is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">quantize_per_channel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_bits</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">**</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="n">x_tmp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">x_tmp</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">zp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="n">x_tmp</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">scales</span><span class="p">))</span>
    <span class="n">q_x</span> <span class="o">=</span> <span class="n">x_tmp</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">scales</span><span class="p">)</span> <span class="o">+</span> <span class="n">zp</span>
    <span class="n">q_x</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span><span class="p">)</span><span class="o">.</span><span class="n">round_</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;scales = </span><span class="si">{</span><span class="n">scales</span><span class="si">}</span><span class="s2">, </span><span class="se">\n</span><span class="s2"> zp = </span><span class="si">{</span><span class="n">zp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q_x</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">zp</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dequantize_per_channel</span><span class="p">(</span><span class="n">q_x</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">zp</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q_x</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">zp</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">scales</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_x</span> <span class="o">-</span> <span class="n">zp</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">scales</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_x</span> <span class="o">-</span> <span class="n">zp</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt;W_q,<span class="w"> </span>scales,<span class="w"> </span><span class="nv">zp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>quantize_per_channel<span class="o">(</span>W<span class="o">)</span>
<span class="nv">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>tensor<span class="o">([[</span><span class="m">0</span>.0029<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.0036<span class="o">]])</span>,<span class="w"> </span>
<span class="nv">zp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>tensor<span class="o">([[</span>-162.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="w"> </span>-48.<span class="o">]])</span>
&gt;&gt;&gt;W_q
tensor<span class="o">([[</span><span class="w"> </span><span class="m">72</span>.,<span class="w">   </span><span class="m">0</span>.,<span class="w">  </span><span class="m">93</span>.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">207</span>.,<span class="w">   </span><span class="m">0</span>.,<span class="w"> </span><span class="m">139</span>.<span class="o">]])</span>

&gt;&gt;&gt;W_dq<span class="w"> </span><span class="o">=</span><span class="w"> </span>dequantize_per_channel<span class="o">(</span>W_q,<span class="w"> </span>scales,<span class="w"> </span>zp<span class="o">)</span>
&gt;&gt;&gt;W_dq
tensor<span class="o">([[</span><span class="m">0</span>.6837,<span class="w"> </span><span class="m">0</span>.4734,<span class="w"> </span><span class="m">0</span>.7451<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.9301,<span class="w"> </span><span class="m">0</span>.1751,<span class="w"> </span><span class="m">0</span>.6821<span class="o">]])</span>
</pre></div>
</div>
<p>And the loss is</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt;<span class="w"> </span><span class="nv">loss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.nn.MSELoss<span class="o">()(</span>W_dq,<span class="w"> </span>W<span class="o">)</span>
&gt;&gt;&gt;<span class="w"> </span>loss.item<span class="o">()</span>
<span class="m">5</span>.637690492221736e-07
</pre></div>
</div>
<p>Through this example, we can see that per-channel quantization has finer granularity and has lower loss (loss 5.6376e-07 for per-channel quantization and 7.3852e-07 for per-tensor quantization).</p>
</section>
<section id="matmul-quantization-example">
<h4>Matmul quantization example<a class="headerlink" href="#matmul-quantization-example" title="Link to this heading"></a></h4>
<p>For a linear layer in most model, $Y=X \cdot W$, we can quantize both the weights and activations in order to reduce the storage and accelerate inference.
Using per-tensor scale quantization to show the process.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">quantize_per_tensor_absmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n_bits</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">q_max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">scales</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span><span class="o">.</span><span class="n">div_</span><span class="p">(</span><span class="n">q_max</span><span class="p">)</span>
    <span class="n">q_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">scales</span>
    <span class="n">q_x</span> <span class="o">=</span> <span class="n">q_x</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="o">-</span><span class="n">q_max</span><span class="p">,</span> <span class="n">q_max</span><span class="p">)</span><span class="o">.</span><span class="n">round_</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">q_x</span><span class="p">,</span> <span class="n">scales</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dequantize</span><span class="p">(</span><span class="n">q_x</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">q_x</span>
</pre></div>
</div>
<p>Randomly initialize the $W$ and $Y$, then calculate the result of $Y=X \cdot W$</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt;W<span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.rand<span class="o">(</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="nv">dtype</span><span class="o">=</span>torch.float32<span class="o">)</span>
&gt;&gt;&gt;X<span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.rand<span class="o">(</span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span>,<span class="w"> </span><span class="nv">dtype</span><span class="o">=</span>torch.float32<span class="o">)</span>
&gt;&gt;&gt;W
tensor<span class="o">([[</span><span class="m">0</span>.0806,<span class="w"> </span><span class="m">0</span>.7589,<span class="w"> </span><span class="m">0</span>.6038<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.3815,<span class="w"> </span><span class="m">0</span>.5040,<span class="w"> </span><span class="m">0</span>.7174<span class="o">]])</span>
&gt;&gt;&gt;X
tensor<span class="o">([[</span><span class="m">0</span>.5444,<span class="w"> </span><span class="m">0</span>.5826,<span class="w"> </span><span class="m">0</span>.7772,<span class="w"> </span><span class="m">0</span>.5555<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.3740,<span class="w"> </span><span class="m">0</span>.3253,<span class="w"> </span><span class="m">0</span>.0698,<span class="w"> </span><span class="m">0</span>.1381<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.5972,<span class="w"> </span><span class="m">0</span>.0086,<span class="w"> </span><span class="m">0</span>.0737,<span class="w"> </span><span class="m">0</span>.8298<span class="o">]])</span>
&gt;&gt;&gt;Y<span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.matmul<span class="o">(</span>W,<span class="w"> </span>X<span class="o">)</span>
&gt;&gt;&gt;Y
tensor<span class="o">([[</span><span class="m">0</span>.6883,<span class="w"> </span><span class="m">0</span>.2991,<span class="w"> </span><span class="m">0</span>.1601,<span class="w"> </span><span class="m">0</span>.6506<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.8246,<span class="w"> </span><span class="m">0</span>.3924,<span class="w"> </span><span class="m">0</span>.3845,<span class="w"> </span><span class="m">0</span>.8768<span class="o">]])</span>
</pre></div>
</div>
<p>Quantize weight and activation, matmul(quantize(X), quantize(Y))</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt;W_q,<span class="w"> </span><span class="nv">W_scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>quantize_per_tensor_absmax<span class="o">(</span>W<span class="o">)</span>
&gt;&gt;&gt;X_q,<span class="w"> </span><span class="nv">X_scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>quantize_per_tensor_absmax<span class="o">(</span>X<span class="o">)</span>
&gt;&gt;&gt;print<span class="o">(</span>f<span class="s1">&#39;{W_q}\n{W_scale.item()}&#39;</span><span class="o">)</span>
&gt;&gt;&gt;print<span class="o">(</span>f<span class="s1">&#39;{X_q}\n{X_scale.item()}&#39;</span><span class="o">)</span>
tensor<span class="o">([[</span><span class="w"> </span><span class="m">13</span>.,<span class="w"> </span><span class="m">127</span>.,<span class="w"> </span><span class="m">101</span>.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="m">64</span>.,<span class="w">  </span><span class="m">84</span>.,<span class="w"> </span><span class="m">120</span>.<span class="o">]])</span>
<span class="m">0</span>.0059755356051027775
tensor<span class="o">([[</span><span class="w"> </span><span class="m">83</span>.,<span class="w">  </span><span class="m">89</span>.,<span class="w"> </span><span class="m">119</span>.,<span class="w">  </span><span class="m">85</span>.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="m">57</span>.,<span class="w">  </span><span class="m">50</span>.,<span class="w">  </span><span class="m">11</span>.,<span class="w">  </span><span class="m">21</span>.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="w"> </span><span class="m">91</span>.,<span class="w">   </span><span class="m">1</span>.,<span class="w">  </span><span class="m">11</span>.,<span class="w"> </span><span class="m">127</span>.<span class="o">]])</span>
<span class="m">0</span>.006533813662827015

&gt;&gt;&gt;Y_q<span class="w"> </span><span class="o">=</span><span class="w"> </span>torch.matmul<span class="o">(</span>W_q,<span class="w"> </span>X_q<span class="o">)</span>
&gt;&gt;&gt;Y_q
tensor<span class="o">([[</span><span class="m">17509</span>.,<span class="w">  </span><span class="m">7608</span>.,<span class="w">  </span><span class="m">4055</span>.,<span class="w"> </span><span class="m">16599</span>.<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">21020</span>.,<span class="w"> </span><span class="m">10016</span>.,<span class="w">  </span><span class="m">9860</span>.,<span class="w"> </span><span class="m">22444</span>.<span class="o">]])</span>
&gt;&gt;&gt;Y_dq<span class="w"> </span><span class="o">=</span><span class="w"> </span>dequantize<span class="o">(</span>Y_q,<span class="w"> </span>W_scale<span class="w"> </span>*<span class="w"> </span>X_scale<span class="o">)</span>
&gt;&gt;&gt;Y_dq
tensor<span class="o">([[</span><span class="m">0</span>.6836,<span class="w"> </span><span class="m">0</span>.2970,<span class="w"> </span><span class="m">0</span>.1583,<span class="w"> </span><span class="m">0</span>.6481<span class="o">]</span>,
<span class="w">        </span><span class="o">[</span><span class="m">0</span>.8207,<span class="w"> </span><span class="m">0</span>.3911,<span class="w"> </span><span class="m">0</span>.3850,<span class="w"> </span><span class="m">0</span>.8763<span class="o">]])</span>
</pre></div>
</div>
</section>
<section id="per-channel-limitation">
<h4>Per-channel limitation<a class="headerlink" href="#per-channel-limitation" title="Link to this heading"></a></h4>
<p>Though per-channel quantization could bring lower quantization error, we could not apply it for activations due to the difficulty of the dequantization. We would prove it in the following image and the zero point of quantization would be ignored for simplicity.</p>
<p>The image on the left presents a normal linear forward  with 1x2 input $x$ and 2x2 weight $w$. The results $y$ could be easily obtained by simple mathematics. In the middle image, we apply per-tensor quantization for activations and per-channel quantization for weights; the results after quantization that are denoted by $y_1$ and $y_2$, could be easily dequantized to the float results $y_{fp1}$ and $y_{fp2}$ by per channel scale $1.0/s_1s_x$ and $1.0/s_2s_x$. However, after applying per-channel quantization for activation (right image), we could not dequantize the  $y_1$ and  $y_2$ to float results.</p>
<div align="center">
    <img src="./imgs/sq_pc.png"/>
</div></section>
</section>
</section>
<section id="smoothquant-and-our-enhancement">
<h2>SmoothQuant and Our Enhancement<a class="headerlink" href="#smoothquant-and-our-enhancement" title="Link to this heading"></a></h2>
<section id="smoothquant">
<h3>SmoothQuant<a class="headerlink" href="#smoothquant" title="Link to this heading"></a></h3>
<p>In the previous subsection, we have explained why per-channel quantization could not be applied for activation, even though it could lead to lower quantization loss. However, the quantization error loss of activation plays an important role in the accuracy loss of model quantization[^2][^3][^4].</p>
<p>To reduce the quantization loss of activations, lots of methods have been proposed. In the following, we briefly introduce SPIQ[^2], Outlier Suppression[^3] and Smoothquant[^4]. All these three methods share a similar idea to migrate the difficulty from activation quantization to weight quantization but differ in how much difficulty to be transferred.</p>
<p>So <strong>the first question is how to migrate the difficulty from activation to weights?</strong> The solution is straightforward, that is to convert the network to an output equivalent network that is presented in the image below and apply quantization to this equivalent network. The intuition is that each channel of activation could be scaled to make it more quantization-friendly, similar to a fake per-channel activation quantization.</p>
<div align="center">
    <img src="./imgs/sq_convert.png"/>
</div><p>Please note that this conversion will make the quantization of weights more difficult, because the scales attached to weights shown above are per-input-channel, while quantization of weights is per-output-channel or per-tensor.</p>
<p>So <strong>the second question is how much difficulty to be migrated</strong>, that is how to choose the <strong>conversion per-channel scale</strong> $s_{x1}$ and $s_{x2}$ from the above image. Different works adopt different ways.</p>
<p><em>SPIQ</em> just adopts the quantization scale of activations as the conversion per-channel scale.</p>
<p><em>Outlier suppression</em> adopts the scale of the preceding layernorm as the conversion per-channel scale.</p>
<p><em>Smoothquant</em> introduces a hyperparameter $\alpha$ as a smooth factor to calculate the conversion per-channel scale and balance the quantization difficulty of activation and weight.</p>
<p>$$
s_j = max(|X_j|)^\alpha/max(|W_j|)^{1-\alpha} \tag{4}
$$</p>
<p>j is the index of the input channels.</p>
<div align="center">
    <img src="./imgs/smoothquant.png" height="250"/>
</div><p>For most of the models such as OPT and BLOOM, $\alpha = 0.5$ is a well-balanced value to split the difficulty of weight and activation quantization. A larger $\alpha$ value could be used on models with more significant activation outliers to migrate more quantization difficulty to weights.</p>
</section>
<section id="our-enhancement">
<h3>Our enhancement:<a class="headerlink" href="#our-enhancement" title="Link to this heading"></a></h3>
<section id="algorithm-auto-tuning-of-alpha">
<h4>Algorithm: Auto-tuning of $\alpha$.<a class="headerlink" href="#algorithm-auto-tuning-of-alpha" title="Link to this heading"></a></h4>
<p>SmoothQuant method aims to split the quantization difficulty of weight and activation by using a fixed-value $\alpha$ for an entire model. However, as the distributions of activation outliers vary not only across different models but also across different layers within a model, we hereby propose a method to obtain layer-wise optimal $\alpha$ values with the ability to tune automatically.
Currently, both layer-wise and block-wise auto-tuning methods are supported and the default option is layer-wise.
In block-wise auto-tuning, layers within one block (e.g an OPTDecoderLayer) would share the same alpha value; users could set <em>‘do_blockwise’: True</em> in <em>auto_alpha_args</em> to enable it.</p>
<p>Our proposed method consists of 8 major steps:</p>
<ul class="simple">
<li><p>Hook input minimum and maximum values of layers to be smoothed using register_forward_hook.</p></li>
<li><p>Find a list of layers on which smoothquant could be performed.</p></li>
<li><p>Generate a list of $\alpha$ values of a user-defined range and set a default $\alpha$ value.</p></li>
<li><p>Calculate smoothing factor using default $\alpha$ value, adjust parameters accordingly and forward the adjusted model given an input sample.</p></li>
<li><p>Perform per-channel quantization_dequantization of weights and per-tensor quantization_dequantization of activations to predict output.</p></li>
<li><p>Calculate the layer-wise/block-wise loss with respect to FP32 output, iterate the previous two steps given each $\alpha$ value and save the layer-wise/block-wise loss per alpha.</p></li>
<li><p>Apply criterion on input LayerNorm op and obtain the optimal alpha values of a single input sample.</p></li>
<li><p>Iterate the previous three steps over a number of input samples and save the layer-wise/block-wise optimal $\alpha$ values.</p></li>
</ul>
<p>Multiple criteria (e.g min, max and mean) are supported to determine the $\alpha$ value of an input LayerNorm op of a transformer block. Both alpha range and criterion could be configured in auto_alpha_args.</p>
<p>In our experiments, an $\alpha$ range of [0.0, 1.0] with a step_size of 0.1 is found to be well-balanced one for the majority of models.</p>
</section>
<section id="engineering">
<h4>Engineering<a class="headerlink" href="#engineering" title="Link to this heading"></a></h4>
<p><em>fully automated</em>: users only need to pass a model and dataloader.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">neural_compressor.adaptor.torch_utils.waq</span><span class="w"> </span><span class="kn">import</span> <span class="n">TorchSmoothQuant</span>

<span class="n">sq</span> <span class="o">=</span> <span class="n">TorchSmoothQuant</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>  <span class="c1">##alpha could be a float number to disable auto-tuning and enable fixed-value alpha smoothquant.</span>
<span class="n">auto_alpha_args</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">sq</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">auto_alpha_args</span><span class="o">=</span><span class="n">auto_alpha_args</span><span class="p">)</span>
</pre></div>
</div>
<p>please note that we rely on torch jit to analyze the model. If you are using huggingface model, you could set torchscript to True when loading the model or set the return_dict to False”</p>
<p><em>support lots of fusing patterns</em>: when applying the conversion per-channel scales, a mul layer needs to be inserted, which will introduce some overhead. The official code fuses this op to the previous layernorm, while we support more fusing patterns, like linear_1-&gt;relu-&gt;linear_2, which means the scales of linear_1 will be fused to linear_2. All the supported patterns are shown below. Currently we only handle the layer whose scale could be fused, we are trying to support other layers, please stay tuned.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>conv2d/linear-&gt;relu/leakyrelu/hardtanh-&gt;conv2d/linear/layernorm/batchnorm/instancenorm/t5norm/llamanorm/groupnorm/

conv2d/linear-&gt;conv2d/linear/layernorm/batchnorm/instancenorm/t5norm/llamanorm/groupnorm
</pre></div>
</div>
</section>
</section>
</section>
<section id="validated-models">
<h2>Validated Models<a class="headerlink" href="#validated-models" title="Link to this heading"></a></h2>
<p>Neural Compressor: 2.1</p>
<p>IPEX (Intel Extension for PyTorch): 2.0/2.1</p>
<p>Dataset: lambada_openai</p>
<p>Task: text-generation provided by <a class="reference external" href="https://github.com/intel/intel-extension-for-transformers/tree/main/examples/huggingface/pytorch/text-generation/quantization">ITREX</a></p>
<p>alpha [0.4, 0.6] is sweet spot region in SmoothQuant paper.</p>
<p>A list of models that achieved a &lt;1% accuracy drop is shown below.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Model/Last token accuracy</th>
<th style="text-align: center;">FP32 Accuracy</th>
<th style="text-align: center;">INT8 (w/ SmoothQuant)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">bigscience/bloom-560m</td>
<td style="text-align: center;">0.354</td>
<td style="text-align: center;">0.3542</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloom-1b7</td>
<td style="text-align: center;">0.4634</td>
<td style="text-align: center;">0.4936</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloom-3b</td>
<td style="text-align: center;">0.518</td>
<td style="text-align: center;">0.5185</td>
<td>alpha=0.8, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloom-7b1</td>
<td style="text-align: center;">0.5764</td>
<td style="text-align: center;">0.5977</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloomz-560m</td>
<td style="text-align: center;">0.3947</td>
<td style="text-align: center;">0.3930</td>
<td>alpha=0.8, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloomz-1b7</td>
<td style="text-align: center;">0.4828</td>
<td style="text-align: center;">0.4906</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloomz-3b</td>
<td style="text-align: center;">0.5018</td>
<td style="text-align: center;">0.4980</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">bigscience/bloomz-7b1</td>
<td style="text-align: center;">0.5593</td>
<td style="text-align: center;">0.5552</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-125m</td>
<td style="text-align: center;">0.379</td>
<td style="text-align: center;">0.3757</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-350m</td>
<td style="text-align: center;">0.4516</td>
<td style="text-align: center;">0.4533</td>
<td>alpha=0.8, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-1.3b</td>
<td style="text-align: center;">0.5789</td>
<td style="text-align: center;">0.5742</td>
<td>alpha=0.8, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-2.7b</td>
<td style="text-align: center;">0.6365</td>
<td style="text-align: center;">0.6404</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-6.7b</td>
<td style="text-align: center;">0.6769</td>
<td style="text-align: center;">0.6804</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-13b</td>
<td style="text-align: center;">0.6872</td>
<td style="text-align: center;">0.6814</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-30b</td>
<td style="text-align: center;">0.7149</td>
<td style="text-align: center;">0.7128</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">facebook/opt-66b</td>
<td style="text-align: center;">0.7398</td>
<td style="text-align: center;">0.7326</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-7b</td>
<td style="text-align: center;">0.7361</td>
<td style="text-align: center;">0.7357</td>
<td>alpha=0.8, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-13b</td>
<td style="text-align: center;">0.7627</td>
<td style="text-align: center;">0.7590</td>
<td>alpha=0.7, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-30b</td>
<td style="text-align: center;">0.7759</td>
<td style="text-align: center;">0.7840</td>
<td>alpha=0.7, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-65b</td>
<td style="text-align: center;">0.7908</td>
<td style="text-align: center;">0.7957</td>
<td>alpha=0.9, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-2-7b-hf*</td>
<td style="text-align: center;">0.7392</td>
<td style="text-align: center;">0.7335</td>
<td>alpha=Auto, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-2-7b-Chat*</td>
<td style="text-align: center;">0.7058</td>
<td style="text-align: center;">0.6994</td>
<td>alpha=Auto, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">LLaMa-2-13b-hf*</td>
<td style="text-align: center;">0.7677</td>
<td style="text-align: center;">0.7615</td>
<td>alpha=Auto, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">EleutherAI/gpt-j-6B*</td>
<td style="text-align: center;">0.6831</td>
<td style="text-align: center;">0.6821</td>
<td>alpha=1.0, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">MBZUAI/LaMini-GPT-124m</td>
<td style="text-align: center;">0.3804</td>
<td style="text-align: center;">0.3887</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">MBZUAI/LaMini-GPT-774m</td>
<td style="text-align: center;">0.5048</td>
<td style="text-align: center;">0.5057</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">MBZUAI/LaMini-GPT-1.5b</td>
<td style="text-align: center;">0.5443</td>
<td style="text-align: center;">0.5436</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">mosaicml/mpt-7b-chat</td>
<td style="text-align: center;">0.655</td>
<td style="text-align: center;">0.6499</td>
<td>alpha=0.7, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">stabilityai/stablelm-base-alpha-3b</td>
<td style="text-align: center;">0.4172</td>
<td style="text-align: center;">0.4149</td>
<td>alpha=0.6, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">togethercomputer/RedPajama-INCITE-Base-3B-v1</td>
<td style="text-align: center;">0.6542</td>
<td style="text-align: center;">0.6735</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">togethercomputer/RedPajama-INCITE-Chat-3B-v1*</td>
<td style="text-align: center;">0.6718</td>
<td style="text-align: center;">0.6740</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">togethercomputer/RedPajama-INCITE-Instruct-3B-v1*</td>
<td style="text-align: center;">0.6569</td>
<td style="text-align: center;">0.6621</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">togethercomputer/RedPajama-INCITE-Base-7B-v0.1*</td>
<td style="text-align: center;">0.7143</td>
<td style="text-align: center;">0.7221</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">togethercomputer/RedPajama-INCITE-Instruct-7B-v0.1*</td>
<td style="text-align: center;">0.6895</td>
<td style="text-align: center;">0.6953</td>
<td>alpha=0.5, Ipex 2.0</td>
</tr>
<tr>
<td style="text-align: center;">databricks/dolly-v1-6b*</td>
<td style="text-align: center;">0.6866</td>
<td style="text-align: center;">0.6895</td>
<td>alpha=0.8, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">databricks/dolly-v2-3b*</td>
<td style="text-align: center;">0.6297</td>
<td style="text-align: center;">0.6247</td>
<td>alpha=0.5, Ipex 2.1</td>
</tr>
<tr>
<td style="text-align: center;">tiiuae/falcon-7b-instruct</td>
<td style="text-align: center;">0.6437</td>
<td style="text-align: center;">0.6392</td>
<td>alpha=0.7, Pytorch</td>
</tr>
</tbody>
</table><p>The results listed below are achieved using IPEX optimize_transformers in model initialization for better performance.<br />| Model/Last token accuracy |  FP32 Accuracy   | INT8 (w/ SmoothQuant) | Notes |
|:———-:|:——:|:——:|———————————–|
| LLaMa-2-7b-hf* | 0.7392 | 0.7332  | alpha=Auto, Ipex 2.1 |
| LLaMa-2-13b-hf* | 0.7677 | 0.7632  | alpha=Auto, Ipex 2.1 |</p>
<p>Please note that for models with asterisk(*), we have set all add ops to FP32 during quantization step to achieve desirable results.</p>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading"></a></h2>
<p>There are two ways to apply smooth quantization: 1) using a fixed <code class="docutils literal notranslate"><span class="pre">alpha</span></code> for the entire model or 2) determining the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> through auto-tuning.</p>
<section id="using-a-fixed-alpha">
<h3>Using a fixed <code class="docutils literal notranslate"><span class="pre">alpha</span></code><a class="headerlink" href="#using-a-fixed-alpha" title="Link to this heading"></a></h3>
<p>To set a fixed alpha for the entire model, users can follow this example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">recipes</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;smooth_quant&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="s2">&quot;smooth_quant_args&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="s2">&quot;folding&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
<span class="n">conf</span> <span class="o">=</span> <span class="n">PostTrainingQuantConfig</span><span class="p">(</span><span class="n">recipes</span><span class="o">=</span><span class="n">recipes</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">smooth_quant_args</span></code> description:</p>
<p>“alpha”: a float value. Default is 0.5.</p>
<p>“folding”: whether to fold mul into the previous layer, where mul is required to update the input distribution during smoothing.</p>
<ul class="simple">
<li><p>True: Fold inserted mul into the previous layer. IPEX will only insert mul for layers can do folding.</p></li>
<li><p>False: Allow inserting mul to update the input distribution and no folding. IPEX (version&gt;=2.1) can fuse inserted mul automatically. For Stock PyTorch, setting folding=False will convert the model to a QDQ model.</p></li>
</ul>
</section>
<section id="determining-the-alpha-through-auto-tuning">
<h3>Determining the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> through auto-tuning<a class="headerlink" href="#determining-the-alpha-through-auto-tuning" title="Link to this heading"></a></h3>
<p>Users can search for the best <code class="docutils literal notranslate"><span class="pre">alpha</span></code> at two levels: 1) for the entire model, and 2) for each layer/block.</p>
<section id="auto-tune-the-alpha-for-the-entire-model">
<h4>Auto-tune the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> for the entire model<a class="headerlink" href="#auto-tune-the-alpha-for-the-entire-model" title="Link to this heading"></a></h4>
<p>The tuning process looks for the optimal <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value from a list of <code class="docutils literal notranslate"><span class="pre">alpha</span></code> values provided by the user.</p>
<blockquote>
<div><p>Please note that, it may a considerable amount of time as the tuning process applies each <code class="docutils literal notranslate"><span class="pre">alpha</span></code> to the entire model and uses the evaluation result on the entire dataset as the metric to determine the best <code class="docutils literal notranslate"><span class="pre">alpha</span></code>.
Here is an example:</p>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">conf</span> <span class="o">=</span> <span class="n">PostTrainingQuantConfig</span><span class="p">(</span>
    <span class="n">quant_level</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="c1"># quant_level can also be 1</span>
    <span class="o">...</span>
    <span class="n">recipes</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;smooth_quant&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> 
             <span class="s2">&quot;smooth_quant_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
    <span class="o">...</span>
    <span class="p">}</span><span class="err">）</span>
</pre></div>
</div>
</section>
<section id="auto-tune-the-alpha-for-each-layer-block">
<h4>Auto-tune the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> for each layer/block<a class="headerlink" href="#auto-tune-the-alpha-for-each-layer-block" title="Link to this heading"></a></h4>
<p>In this case, the tuning process searches the optimal <code class="docutils literal notranslate"><span class="pre">alpha</span></code> of each layer of the block by evaluating the loss with respect to FP32 output on a few batches of data.
Here is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">recipes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;smooth_quant&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> 
    <span class="s2">&quot;default_alpha&quot;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">,</span> <span class="c1"># Baseline alpha-value for auto-tuning.</span>
    <span class="s2">&quot;smooth_quant_args&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s2">&quot;auto_alpha_args&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;alpha_min&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="c1"># min value of auto-tuning alpha search space</span>
        <span class="s2">&quot;alpha_max&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="c1"># max value of auto-tuning alpha search space</span>
        <span class="s2">&quot;alpha_step&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="c1"># step_size of auto-tuning alpha search space</span>
        <span class="s2">&quot;shared_criterion&quot;</span><span class="p">:</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="c1"># Criterion for input LayerNorm op of a transformer block.</span>
        <span class="s2">&quot;do_blockwise&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="c1"># Whether to enable block-wise auto-tuning.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">conf</span> <span class="o">=</span> <span class="n">PostTrainingQuantConfig</span><span class="p">(</span><span class="n">recipes</span><span class="o">=</span><span class="n">recipes</span><span class="err">）</span>
</pre></div>
</div>
<p>To get more information, please refer to <a class="reference external" href="https://github.com/intel/neural-compressor/blob/master/examples/deprecated/pytorch/nlp/huggingface_models/language-modeling/quantization/llm">examples</a>.</p>
</section>
</section>
</section>
<section id="supported-framework-matrix">
<h2>Supported Framework Matrix<a class="headerlink" href="#supported-framework-matrix" title="Link to this heading"></a></h2>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Framework</th>
<th>Alpha</th>
<th>Folding</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">PyTorch</td>
<td>[0-1] / 'auto'</td>
<td>False</td>
</tr>
<tr>
<td style="text-align: center;">IPEX</td>
<td>[0-1] / 'auto'</td>
<td>True / False(Version&gt;2.1)</td>
</tr>
<tr>
<td style="text-align: center;">ONNX</td>
<td>[0-1]</td>
<td>True</td>
</tr>
<tr>
<td style="text-align: center;">Tensorflow</td>
<td>[0-1]</td>
<td>False</td>
</tr>
<tr>
<td style="text-align: center;">ITEX</td>
<td>[0-1]</td>
<td>False</td>
</tr>
</tbody>
</table></section>
<section id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Link to this heading"></a></h2>
<p>[^1]: Jason, Wei, et al. “Emergent Abilities of Large Language Models”. Published in Transactions on Machine Learning Research (2022).</p>
<p>[^2]: Yvinec, Edouard, et al. “SPIQ: Data-Free Per-Channel Static Input Quantization.” Proceedings of the IEEE/CVF Winter Conference on Applications of Computer Vision. 2023.</p>
<p>[^3]: Wei, Xiuying, et al. “Outlier suppression: Pushing the limit of low-bit transformer language models.” arXiv preprint arXiv:2209.13325 (2022).</p>
<p>[^4]: Xiao, Guangxuan, et al. “Smoothquant: Accurate and efficient post-training quantization for large language models.” arXiv preprint arXiv:2211.10438 (2022).</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Intel® Neural Compressor, Intel.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   <jinja2.runtime.BlockReference object at 0x7fe9b7a6d370> 
  <p></p><div><a href='https://www.intel.com/content/www/us/en/privacy/intel-cookie-notice.html' data-cookie-notice='true'>Cookies</a> <a href='https://www.intel.com/content/www/us/en/privacy/intel-privacy-notice.html'>| Privacy</a></div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>